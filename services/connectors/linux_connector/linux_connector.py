import netmiko
import paramiko
import os
from nameko.rpc import rpc, RpcProxy


class SSH:
    """
        Linux SSH Connector Service
        Function that performs the application via ssh of the rules generated by the translation modules
        Receive parameters:
          - host: management ip of the device that will receive the rules
          - port: device ssh port
          - username: device username for ssh access
          - password: device password for ssh access
          - device_type: indicates the device's OS 'cisco_ios' or 'linux', other devices_type are available
          in the netmiko documentation
          - command: set of commands generated by the translator module
        Return:
          - String 'ERROR': if an error is identified in the application of the rules
          - String 'OK': successful application of the rules
    """

    name = "linux_connector"
    zipcode_rpc = RpcProxy('linux_service_connector')

    @rpc
    def apply_config(self, host, port, username, password, device_type, commands,device):
        with open('.command.txt', 'w+b') as archive:
            archive.write(commands.encode())
        archive = open('.command.txt', 'r')
        try:
            ssh_session = netmiko.ConnectHandler(device_type=device_type, ip=host, port=port, username=username, password=password)
            ssh_session.send_command_expect("sudo su" + '\n', expect_string=": ", cmd_verify=False)
            ssh_session.send_command_expect(password + '\n', expect_string="# ", cmd_verify=False)
            if device == 'openflow':
                ssh_session.send_command_expect('docker attach competent_bose' + '\n', expect_string="# ")
            for line in archive:
                print('Linha: ' + line)
                output = ssh_session.send_command(line + '\n', expect_string="#", cmd_verify=False)
                print('Retorno: ' + output)
            if device == 'openflow':
                output = ssh_session.send_command_timing('\x10\x11')
                print('Retorno: ' + output)
            output = ssh_session.send_command_timing('exit\n')
            print('Retorno: ' + output)
            output = ssh_session.send_command_timing('exit\n')
            print('Retorno: ' + output)
            #ssh_session.disconnect()

            return 'OK'
        except(netmiko.ssh_exception.NetMikoAuthenticationException,
               netmiko.ssh_exception.NetMikoTimeoutException,
               paramiko.ssh_exception.SSHException) as s_error:
            print(s_error)
        archive.close()
        os.remove('.command.txt')
        return 'OK'



